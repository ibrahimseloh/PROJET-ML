================================================================================
                    ASTRALI - ASSISTANT FINANCIER IA
                    RAPPORT TECHNIQUE COMPLET
================================================================================

Date: DÃ©cembre 2025
Version: 1.0
Auteurs: Fofana Ibrahim Seloh, Aya EL KOUACH, Mehdi Chanaa

================================================================================
TABLE DES MATIÃˆRES
================================================================================

1. RÃ‰SUMÃ‰ EXÃ‰CUTIF
2. ARCHITECTURE GÃ‰NÃ‰RALE
3. STACK TECHNOLOGIQUE
4. PIPELINE DE VALIDATION API
5. MODE PDF - TRAITEMENT ET RAG
6. MODE YFINANCE - TRAITEMENT ET RAG
7. SYSTÃˆME D'INDEXATION DES SOURCES
8. FLUX DE TRAITEMENT COMPLET
9. PERFORMANCES ET OPTIMISATIONS
10. SÃ‰CURITÃ‰ ET BONNES PRATIQUES

================================================================================
1. RÃ‰SUMÃ‰ EXÃ‰CUTIF
================================================================================

Astrali est un assistant financier intelligent basÃ© sur l'architecture RAG
(Retrieval-Augmented Generation) qui combine :

â€¢ Google Gemini 2.5-Flash pour la gÃ©nÃ©ration de rÃ©ponses intelligentes
â€¢ Deux modes de traitement : PDF (documents financiers) et YFinance (donnÃ©es temps rÃ©el)
â€¢ Un systÃ¨me de validation robuste d'API avec dÃ©tection d'erreurs granulaires
â€¢ Une indexation avancÃ©e des sources avec traÃ§abilitÃ© complÃ¨te
â€¢ Une interface Streamlit moderne et responsive

1.1 INTRODUCTION DÃ‰TAILLÃ‰E
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Astrali rÃ©sout un problÃ¨me fondamental dans l'analyse financiÃ¨re : la nÃ©cessitÃ©
de combiner plusieurs sources d'information (documents, donnÃ©es de marchÃ©) avec
une analyse intelligente pour fournir des insights actionables.

Le projet utilise le paradigme RAG (Retrieval-Augmented Generation) qui se
distingue des approches classiques de deux faÃ§ons :

1. SANS RAG (LLM seul):
   Question â†’ LLM â†’ RÃ©ponse gÃ©nÃ©rÃ©e
   ProblÃ¨me: LLM ne connaÃ®t pas vos documents spÃ©cifiques, connaissances datÃ©es

2. AVEC RAG (Notre approche):
   Question â†’ RÃ©cupÃ©ration docs pertinents â†’ LLM voit contexte â†’ RÃ©ponse informÃ©e
   Avantage: RÃ©ponses basÃ©es sur VOS donnÃ©es, sources traÃ§ables, prÃ©cision accrue

La philosophie d'Astrali repose sur trois principes clÃ©s :

A. ACCESSIBILITÃ‰
   - Interface web simple (pas d'installation)
   - Gratuit avec Google Gemini API
   - Configuration minimale (juste une clÃ© API)
   - Documentation complÃ¨te en franÃ§ais

B. TRAÃ‡ABILITÃ‰
   - Chaque rÃ©ponse cite ses sources exactes
   - Vous pouvez vÃ©rifier les informations utilisÃ©es
   - Audit trail complet du processus
   - Pas de "hallucinations" sans justification

C. FLEXIBILITÃ‰
   - Deux modes complÃ©mentaires (PDF + YFinance)
   - Architecture modulaire pour extensions futures
   - Configuration fine des paramÃ¨tres RAG
   - Extensible Ã  d'autres sources de donnÃ©es

1.2 VISION TECHNIQUE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Astrali fonctionne selon une architecture en trois couches :

COUCHE 1 - PRÃ‰SENTATION (Interface utilisateur)
â”œâ”€ Framework: Streamlit
â”œâ”€ ResponsabilitÃ©s:
â”‚  â”œâ”€ Authentification via API key
â”‚  â”œâ”€ Gestion UI des deux modes
â”‚  â”œâ”€ Affichage rÃ©ponses + sources
â”‚  â””â”€ Visualisations (graphiques, PDFs)
â””â”€ Interaction: Utilisateur â†” Frontend web

COUCHE 2 - TRAITEMENT (Logique mÃ©tier)
â”œâ”€ Module PDF: Extraction, chunking, indexation
â”œâ”€ Module YFinance: TÃ©lÃ©chargement, transformation, indexation
â”œâ”€ Module RAG: Retrieval, re-ranking, contexte
â”œâ”€ Module LLM: GÃ©nÃ©ration rÃ©ponses via Gemini API
â””â”€ Interaction: Conversion donnÃ©es brutes â†’ insights

COUCHE 3 - DONNÃ‰ES (Sources)
â”œâ”€ Source 1: Fichiers PDF (utilisateur upload)
â”œâ”€ Source 2: API YFinance (donnÃ©es de marchÃ© temps rÃ©el)
â”œâ”€ Source 3: Embeddings (reprÃ©sentation vectorielle)
â””â”€ Interaction: Stockage + RÃ©cupÃ©ration efficace

Le flux gÃ©nÃ©ral fonctionne ainsi :

   UTILISATEUR
       â†“
   [INTERFACE STREAMLIT]
       â”œâ”€ Validate API key
       â””â”€ Route vers mode
          â”œâ”€ Mode PDF: Upload â†’ Processing
          â””â”€ Mode YFinance: Select tickers â†’ Fetch data
       â†“
   [MOTEUR RAG]
       â”œâ”€ Index sources (embeddings)
       â””â”€ Query processing (similaritÃ© + reranking)
       â†“
   [GEMINI LLM]
       â””â”€ Generate answer with context
       â†“
   [INDEX SOURCES]
       â””â”€ Track used chunks/data
       â†“
   [PRÃ‰SENTATION RÃ‰SULTAT]
       â”œâ”€ Answer formatted in markdown
       â”œâ”€ Sources clickable avec mÃ©tadata
       â””â”€ Chat history sauvegardÃ©

================================================================================
2. ARCHITECTURE GÃ‰NÃ‰RALE
================================================================================

2.1 COMPOSANTS PRINCIPAUX
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      INTERFACE STREAMLIT                            â”‚
â”‚        (Landing Page â†’ API Validation â†’ Mode Selection)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚             â”‚
        â–¼             â–¼             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ CONFIG â”‚  â”‚ PDF MODE â”‚  â”‚ YFINANCE â”‚
    â”‚MANAGER â”‚  â”‚  HANDLER â”‚  â”‚  HANDLER â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚             â”‚             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                           â”‚
        â–¼                           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ RAG PIPELINE â”‚          â”‚ RAG PIPELINE â”‚
    â”‚  (PDF Mode)  â”‚          â”‚ (YFinance)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                           â”‚
        â–¼                           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   GEMINI     â”‚          â”‚ SOURCE INDEXER   â”‚
    â”‚   SERVICE    â”‚          â”‚  & TRACKER       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                           â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  STREAMLIT OUTPUT  â”‚
            â”‚  (Response + UI)   â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2.2 FLUX DE DONNÃ‰ES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Input (User) â†’ Validation API â†’ Mode Selection â†’ Processing â†’ RAG Query
                                                                    â†“
                                          Gemini LLM (Generation)
                                                    â†“
                        Source Indexing & Response Construction
                                                    â†“
                    Output (Response + Sources + Metadata)

2.3 INTERACTION DES COMPOSANTS - EXPLICATION DÃ‰TAILLÃ‰E
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Comment les composants collaborent pour traiter une requÃªte utilisateur :

Ã‰TAPE 1: AUTHENTIFICATION API
Lorsque l'utilisateur entre sa clÃ© API et clique "Connecter":
â€¢ La clÃ© passe par 5 Ã©tapes de validation (vÃ©rifiÃ©es plus tard)
â€¢ Si valide, GeminiService est initialisÃ© en mÃ©moire session
â€¢ Cette instance est rÃ©utilisÃ©e pour TOUTES les requÃªtes futures
â€¢ Avantage: Une seule clÃ© API pour toute la session

Ã‰TAPE 2: SÃ‰LECTION MODE
L'utilisateur choisit entre deux modes:

A. MODE PDF:
   â”œâ”€ Upload PDF â†’ StockÃ© en fichier temporaire
   â”œâ”€ PDFRagPipeline.__init__() lance traitement immÃ©diat
   â”œâ”€ Extraction complÃ¨te et indexation en mÃ©moire
   â”œâ”€ PrÃªt pour queries (zÃ©ro latence supplÃ©mentaire)
   â””â”€ Avantage: RÃ©ponses rapides sur mÃªme PDF

B. MODE YFINANCE:
   â”œâ”€ SÃ©lection tickers (multi-select dropdown)
   â”œâ”€ Click "Charger" â†’ yfinance.download() en temps rÃ©el
   â”œâ”€ Transformation donnÃ©es â†’ chunks textuels
   â”œâ”€ Indexation embeddings
   â””â”€ Avantage: DonnÃ©es toujours actualisÃ©es

Ã‰TAPE 3: TRAITEMENT SOURCE
Chaque mode traite diffÃ©remment mais converge vers le mÃªme format:

PDF Path:
  â”œâ”€ pdfplumber.open()
  â”œâ”€ Extraction texte par page
  â”œâ”€ Nettoyage + normalization
  â”œâ”€ Chunking avec overlap
  â””â”€ â†’ List[chunks avec metadata page]

YFinance Path:
  â”œâ”€ yfinance.download(tickers, period)
  â”œâ”€ RÃ©cupÃ©ration OHLCV + volumes
  â”œâ”€ Transformation â†’ chunks texte structurÃ©s
  â””â”€ â†’ List[chunks avec metadata ticker/date]

RÃ©sultat convergent: Chunks indexÃ©s avec metadata + embeddings

Ã‰TAPE 4: QUERY RAG
User question â†’ MÃªme pipeline RAG quel que soit la source:
  â”œâ”€ Embedding question (Gemini API)
  â”œâ”€ Calcul similaritÃ© cosinus vs tous les chunks
  â”œâ”€ Tri + Top-K (k=4) retrieval
  â”œâ”€ Re-ranking pour meilleur ordre
  â””â”€ Compilation contexte + sources

Ã‰TAPE 5: GÃ‰NÃ‰RATION RÃ‰PONSE
Prompt construit intelligemment:
  â”œâ”€ Instructions au modÃ¨le
  â”œâ”€ Contexte (top chunks)
  â”œâ”€ Question utilisateur
  â”œâ”€ Format demandÃ© (markdown, structure)
  â””â”€ â†’ Gemini API rÃ©pond

Ã‰TAPE 6: POST-PROCESSING
Avant d'afficher:
  â”œâ”€ Conversion markdown â†’ HTML (styling)
  â”œâ”€ Extraction sources utilisÃ©es
  â”œâ”€ Mapping sources â†’ liens (pages PDF / data financiÃ¨re)
  â”œâ”€ Construction mÃ©tadata (tokens, temps, mode)
  â””â”€ Sauvegarde dans chat history

Ã‰TAPE 7: AFFICHAGE FINAL
L'utilisateur voit:
  â”œâ”€ RÃ©ponse formatÃ©e en Markdown
  â”œâ”€ Sources cliquables (liens interactifs)
  â”œâ”€ Indicateurs pertinence (scores de similaritÃ©)
  â”œâ”€ MÃ©tadata (tokens, model, temps)
  â””â”€ Input prÃªt pour nouvelle question

================================================================================
3. STACK TECHNOLOGIQUE

3.1 BACKEND TECHNOLOGIQUE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

CORE FRAMEWORK:
  â€¢ Python 3.8+              - Langage principal
  â€¢ Streamlit 1.28+          - Framework web UI
  â€¢ Pydantic                 - Validation de donnÃ©es et configuration

TRAITEMENT DOCUMENTAIRE:
  â€¢ pdfplumber              - Extraction de texte depuis PDF
  â€¢ numpy                   - OpÃ©rations numÃ©riques
  â€¢ regex (re)              - Nettoyage de texte

LLM & IA:
  â€¢ google-generativeai     - SDK Google Gemini API
  â€¢ Google Gemini 2.5-Flash - ModÃ¨le LLM principal

DONNÃ‰ES FINANCIÃˆRES:
  â€¢ yfinance               - RÃ©cupÃ©ration de donnÃ©es de marchÃ©
  â€¢ pandas                 - Manipulation de donnÃ©es financiÃ¨res
  â€¢ plotly                 - Visualisation interactive

UTILITAIRES:
  â€¢ markdown               - Conversion markdown â†’ HTML
  â€¢ tempfile               - Gestion des fichiers temporaires
  â€¢ pathlib                - Gestion des chemins fichier

3.2 STRUCTURE DES FICHIERS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Astrali/
â”œâ”€â”€ streamlit_app/
â”‚   â””â”€â”€ app.py                 # Interface Streamlit (1823 lignes)
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ config.py              # Configuration Gemini
â”‚   â”œâ”€â”€ prompts.py             # Templates de prompts
â”‚   â”‚
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ gemini_service.py  # Wrapper Gemini API
â”‚   â”‚   â”œâ”€â”€ pdf_processor.py   # Extraction & chunking PDF
â”‚   â”‚   â””â”€â”€ yfinance_service.py# RÃ©cupÃ©ration donnÃ©es YFinance
â”‚   â”‚
â”‚   â”œâ”€â”€ rag/
â”‚   â”‚   â”œâ”€â”€ __init__.py        # RAG Pipeline PDF (PDFRagPipeline)
â”‚   â”‚   â””â”€â”€ yfinance_rag.py    # RAG Pipeline YFinance
â”‚   â”‚
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â””â”€â”€ reranker.py        # Re-ranking des documents
â”‚   â”‚
â”‚   â””â”€â”€ agents/
â”‚       â””â”€â”€ __init__.py        # DÃ©finitions d'agents
â”‚
â”œâ”€â”€ README.md                  # Documentation (450+ lignes)
â”œâ”€â”€ requirements.txt           # DÃ©pendances Python
â”œâ”€â”€ RAPPORT_TECHNIQUE.txt      # Ce fichier

3.3 VERSIONS DES DÃ‰PENDANCES CLÃ‰S
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

streamlit==1.28.1
google-generativeai>=0.3.0
pydantic>=2.0.0
pdfplumber>=0.9.0
yfinance>=0.2.28
pandas>=1.3.0
plotly>=5.0.0
numpy>=1.21.0
markdown>=3.4.0

3.4 EXPLICATION GÃ‰NÃ‰RALE DU FONCTIONNEMENT GLOBAL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Astrali fonctionne selon un paradigme que nous appelons "Source-Agnostic RAG"
(RAG indÃ©pendant de la source). Voici comment :

QU'EST-CE QUE LE RAG?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Traditionnellement, un LLM (Large Language Model) comme GPT ou Gemini fonctionne
en gÃ©nÃ©rant du texte basÃ© sur sa connaissance prÃ©-entraÃ®nÃ©e. Cette approche a
des limitations :

1. Connaissances statiques: Le modÃ¨le ne connaÃ®t que ce qu'il a vu en training
2. Pas d'accÃ¨s Ã  vos donnÃ©es: Vos PDFs, donnÃ©es financiÃ¨res restent invisibles
3. Hallucinations: Le modÃ¨le peut "inventer" des informations qui semblent vraies
4. Pas de sources: Impossible de vÃ©rifier oÃ¹ le modÃ¨le a trouvÃ© l'info

RAG rÃ©sout cela en ajoutant une couche de Retrieval (rÃ©cupÃ©ration):

SANS RAG:                    AVEC RAG (Astrali):
Question                     Question
   â†“                            â†“
  LLM  â† Connaissances     Recherche documents
   â†“      prÃ©-apprises        â†“
RÃ©ponse                    LLM â† Contexte + Docs
                              â†“
                           RÃ©ponse + Sources

Le RAG fonctionne en 4 Ã©tapes:

1. INDEXATION: Vos documents/donnÃ©es â†’ Vecteurs (embeddings)
   â€¢ PDF: extraction texte â†’ chunking â†’ embeddings
   â€¢ YFinance: donnÃ©es â†’ transformation texte â†’ embeddings
   â€¢ RÃ©sultat: Index de vecteurs avec mÃ©tadata

2. RETRIEVAL: Question utilisateur â†’ Trouver les chunks pertinents
   â€¢ Question â†’ embedding
   â€¢ SimilaritÃ© cosinus vs tous les embeddings
   â€¢ Top-K chunks retournÃ©s (k=4 dans Astrali)

3. AUGMENTATION: Contexte pertinent ajoutÃ© au prompt
   â€¢ Chunks rÃ©cupÃ©rÃ©s â†’ compilÃ©s en contexte
   â€¢ AjoutÃ©s dans le prompt envoyÃ© au LLM
   â€¢ Format: "Voici les documents pertinents: [...]"

4. GÃ‰NÃ‰RATION: LLM gÃ©nÃ¨re rÃ©ponse en VOYANT le contexte
   â€¢ LLM reÃ§oit: contexte + question + instructions
   â€¢ GÃ©nÃ¨re rÃ©ponse basÃ©e sur le contexte
   â€¢ Peut citer exactement la source (traÃ§abilitÃ©!)

COMMENT ASTRALI APPLIQUE RAG?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Astrali est conÃ§u pour Ãªtre "source-agnostic", c'est-Ã -dire que le mÃªme code
RAG fonctionne indÃ©pendamment de la source des donnÃ©es:

UNIFIED RAG PIPELINE:

   PDF Source          YFinance Source
       â†“                       â†“
   Extract Text        Fetch Data & Transform
       â†“                       â†“
   Clean & Chunk       Create Text Chunks
       â†“                       â†“
   Generate Embeddings Generate Embeddings
       â†“                       â†“
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â†“
         [UNIFIED INDEX]
         List of Chunks with:
         - text content
         - embedding vector
         - metadata (page/ticker/date)
                 â†“
           [RAG QUERY ENGINE]
           1. Embed user question
           2. Find similar chunks
           3. Compile context
           4. Generate answer with LLM
                 â†“
           [INDEXED SOURCES]
           Track exactly which chunks
           were used in the answer
                 â†“
           [USER-FACING OUTPUT]
           Answer + Clickable sources

AVANTAGE DE CETTE ARCHITECTURE:

â€¢ ExtensibilitÃ©: Nouveau format (Excel, CSV, API)? 
  â†’ Juste crÃ©er un nouveau "transformer"
  â†’ Le RAG pipeline reste inchangÃ©

â€¢ CohÃ©rence: MÃªme rÃ©sultat quel que soit la source
  â†’ Utilisateur ne doit pas apprendre deux systÃ¨mes
  â†’ ExpÃ©rience uniforme

â€¢ Performance: Cache et optimisations mutualisÃ©es
  â†’ MÃªme code de retrieval pour tous
  â†’ Optimisations centralisÃ©es

CYCLE DE VIE D'UNE REQUÃŠTE EN DÃ‰TAIL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Prenons un exemple concret. Utilisateur a uploadÃ© un PDF et pose :
"Quels sont les revenus principaux?"

T=0ms: Utilisateur tape et envoie
  â”œâ”€ Question: "Quels sont les revenus principaux?"
  â””â”€ Mode: PDF (dÃ©tectÃ© automatiquement)

T=10ms: RÃ©ception question dans backend
  â”œâ”€ Nettoyage: normalisation texte
  â””â”€ Validation: non-vide, pas de commandes bizarres

T=15ms: Embedding question
  â”œâ”€ Question â†’ Appel Gemini embedding API
  â”œâ”€ RÃ©sultat: vecteur 768-dimensions
  â””â”€ Ce vecteur reprÃ©sente "le sens" de la question

T=25ms: Recherche similaritÃ©
  â”œâ”€ Pour chaque chunk de PDF (ex: 234 chunks):
  â”‚  â””â”€ Calcul cosine_similarity(question_vector, chunk_vector)
  â”œâ”€ RÃ©sultats (ex):
  â”‚  â”œâ”€ Chunk #42: 0.956 (trÃ¨s pertinent!)
  â”‚  â”œâ”€ Chunk #15: 0.931
  â”‚  â”œâ”€ Chunk #67: 0.912
  â”‚  â”œâ”€ Chunk #103: 0.891
  â”‚  â”œâ”€ Chunk #89: 0.856 (moins pertinent)
  â”‚  â””â”€ ... (234 chunks triÃ©s)
  â””â”€ Top-4 sÃ©lectionnÃ©s

T=35ms: Re-ranking (optionnel)
  â”œâ”€ VÃ©rification: ordre fait-il sens?
  â”œâ”€ Ajustement si pertinence peut Ãªtre amÃ©liorÃ©e
  â””â”€ RÃ©sultat final: 4 chunks dans bon ordre

T=40ms: Compilation contexte
  â”œâ”€ Extraction texte des 4 chunks
  â”œâ”€ Extraction mÃ©tadata:
  â”‚  â”œâ”€ Chunk #42: Page 5, caractÃ¨res 250-750
  â”‚  â”œâ”€ Chunk #15: Page 3, caractÃ¨res 100-600
  â”‚  â”œâ”€ Chunk #67: Page 8, caractÃ¨res 400-900
  â”‚  â””â”€ Chunk #103: Page 10, caractÃ¨res 200-700
  â””â”€ Compilation: 2000-3000 caractÃ¨res de contexte

T=50ms: Construction prompt
  â”œâ”€ Template Gemini:
  â”‚  â”œâ”€ SystÃ¨me: "Tu es expert financier..."
  â”‚  â”œâ”€ Contexte: "[Chunk #42 text]\n[Chunk #15 text]\n..."
  â”‚  â”œâ”€ Question: "Quels sont les revenus principaux?"
  â”‚  â””â”€ Instructions: "Utilise UNIQUEMENT le contexte fourni..."
  â””â”€ Prompt final: ~4000 caractÃ¨res

T=55ms: Appel Gemini API
  â”œâ”€ RequÃªte envoyÃ©e Ã  gemini-2.5-flash
  â”œâ”€ ParamÃ¨tres:
  â”‚  â”œâ”€ temperature: 0.7 (Ã©quilibre crÃ©ativitÃ©/factualitÃ©)
  â”‚  â”œâ”€ max_tokens: 2048 (longueur max rÃ©ponse)
  â”‚  â””â”€ top_p: 0.9 (diversitÃ©)
  â””â”€ Connexion: API latence ~100-200ms

T=150-300ms: Gemini gÃ©nÃ¨re rÃ©ponse
  â”œâ”€ LLM traite: contexte + question
  â”œâ”€ "Je vois dans le contexte que..."
  â”œâ”€ GÃ©nÃ©ration progressive (streaming)
  â”œâ”€ RÃ©ponse ~ 500 mots
  â””â”€ Exemple: "D'aprÃ¨s les documents fournis, les revenus 
     principaux proviennent de trois sources..."

T=350ms: Post-processing rÃ©ponse
  â”œâ”€ Nettoyage formatage
  â”œâ”€ Conversion markdown â†’ HTML
  â”œâ”€ Extraction sources utilisÃ©es:
  â”‚  â”œâ”€ Source 1: Page 5 des revenus
  â”‚  â”œâ”€ Source 2: Page 3 dÃ©tail activitÃ©s
  â”‚  â”œâ”€ Source 3: Page 8 chiffres clÃ©s
  â”‚  â””â”€ Source 4: Page 10 analyses
  â””â”€ Construction mÃ©tadata rÃ©ponse

T=370ms: Indexation sources
  â”œâ”€ Sauvegarde chat history:
  â”‚  â”œâ”€ Question: "Quels sont les revenus principaux?"
  â”‚  â”œâ”€ RÃ©ponse: "D'aprÃ¨s les documents..."
  â”‚  â”œâ”€ Mode: "PDF"
  â”‚  â”œâ”€ Timestamp: "2025-12-31 09:47:30"
  â”‚  â”œâ”€ Tokens utilisÃ©s: 1250
  â”‚  â”œâ”€ Temps: 370ms
  â”‚  â””â”€ Sources: [Page 5, Page 3, Page 8, Page 10]
  â””â”€ Index mis Ã  jour

T=380ms: Affichage utilisateur
  â”œâ”€ RÃ©ponse formatÃ©e en Markdown affichÃ©
  â”œâ”€ Sources cliquables:
  â”‚  â”œâ”€ ğŸ“„ Page 5 [Lien vers PDF page 5]
  â”‚  â”œâ”€ ğŸ“„ Page 3 [Lien vers PDF page 3]
  â”‚  â”œâ”€ ğŸ“„ Page 8 [Lien vers PDF page 8]
  â”‚  â””â”€ ğŸ“„ Page 10 [Lien vers PDF page 10]
  â”œâ”€ Chat bubble avec avatar "ğŸ¤– Astrali"
  â”œâ”€ MÃ©tadata affichÃ©e:
  â”‚  â”œâ”€ â±ï¸ Temps: 370ms
  â”‚  â”œâ”€ ğŸ“Š Tokens: 1250
  â”‚  â””â”€ ğŸ”— Sources: 4
  â””â”€ Input rÃ©initialisÃ© pour nouvelle question

TOTAL: ~380ms pour TOUTE l'opÃ©ration!

KEY INSIGHTS DU FONCTIONNEMENT:

1. DEUX NIVEAUX DE CONTEXTE:
   - Contexte utilisateur: Vos PDF, vos donnÃ©es
   - Contexte systÃ¨me: Instructions au LLM

2. COMPRESSION INTELLIGENTE:
   - Question complÃ¨te â†’ Query+K chunks
   - Pas besoin d'envoyer tout le PDF Ã  Gemini
   - CoÃ»t API rÃ©duit, latence diminuÃ©e

3. TRAÃ‡ABILITÃ‰ GARANTIE:
   - Chaque source a une provenance
   - Utilisateur peut vÃ©rifier l'information
   - Audit trail complet

4. Ã‰QUILIBRE QUALITÃ‰/PERFORMANCE:
   - K=4 chunks: Assez de contexte pour rÃ©ponse complÃ¨te
   - Top-K > Rerank: Couverture large + qualitÃ© fine
   - Caching: RequÃªtes multiples ultra-rapides

3.5 LE RÃ”LE CRUCIAL DES EMBEDDINGS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Les embeddings sont le "cÅ“ur" technique du RAG. C'est ce qui permet au systÃ¨me
de comprendre le SENS des documents et des questions.

MAIS QU'EST-CE QU'UN EMBEDDING?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Un embedding est une reprÃ©sentation mathÃ©matique du SENS d'un texte.

Analogie: Imagine que chaque document soit une personne avec ses 
caractÃ©ristiques (taille, poids, couleur cheveux, etc.). Un embedding 
est comme un "profil" numÃ©rique qui capture l'essence.

Exemple simple (2D):
  "Le chiffre d'affaires a augmentÃ©"
  â†“ (embedding)
  [0.8, 0.3]  â† Vecteur 2D

  "Les revenus se sont accentuÃ©s"
  â†“ (embedding)
  [0.82, 0.32] â† TrÃ¨s similaire! (concepts semblables)

  "Le chat dort"
  â†“ (embedding)
  [0.1, 0.9]  â† TrÃ¨s diffÃ©rent! (concepts diffÃ©rents)

La similaritÃ© entre deux vecteurs = cosine_similarity:

  cosine_similarity([0.8, 0.3], [0.82, 0.32]) = 0.999 âœ… TrÃ¨s similaire!
  cosine_similarity([0.8, 0.3], [0.1, 0.9]) = 0.120 âŒ Pas similaire

DANS LA VRAIE VIE:
Astrali utilise Gemini embeddings qui crÃ©ent des vecteurs de dimension 768!
C'est beaucoup plus complexe mais mÃªme principe.

COMMENT ASTRALI UTILISE LES EMBEDDINGS?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

PHASE 1: INDEXATION (Une seule fois, au chargement du PDF)
  
  PDF content:
    Page 1: "Bienvenue dans le rapport annuel. Notre chiffre d'affaires..."
    Page 2: "Les charges d'exploitation se sont accrues de 15%..."
    ...
    Page 50: "En conclusion, le groupe a enregistrÃ©..."
    
    â†“ (Chunking avec overlap)
    
  Chunks:
    Chunk #1: "Bienvenue dans le rapport annuel..."
    Chunk #2: "d'affaires de 2025 s'Ã©lÃ¨ve Ã  1.5Bâ‚¬. Les charges..."
    Chunk #3: "charges d'exploitation se sont accrues de 15%..."
    ...
    Chunk #234: "...groupe a enregistrÃ© une croissance..."
    
    â†“ (Embedding API call)
    
  Embeddings:
    Chunk #1: [0.123, -0.456, 0.789, ...]  (768 dimensions)
    Chunk #2: [0.234, -0.567, 0.890, ...]
    Chunk #3: [0.245, -0.578, 0.901, ...]  â† Similaire Ã  #2!
    ...
    Chunk #234: [0.856, 0.123, -0.234, ...]
    
    â†“ (Sauvegarde en index)
    
  Index sauvegardÃ© en mÃ©moire:
    {
      "chunk_1": {
        "text": "Bienvenue...",
        "embedding": [0.123, -0.456, ...],
        "metadata": {"page": 1, "start_char": 0, "end_char": 500}
      },
      "chunk_2": {
        "text": "d'affaires de 2025...",
        "embedding": [0.234, -0.567, ...],
        "metadata": {"page": 2, "start_char": 0, "end_char": 500}
      },
      ...
    }

PHASE 2: QUERY (Chaque fois qu'utilisateur pose une question)

  Question utilisateur:
    "Quel est le chiffre d'affaires total?"
    
    â†“ (Embedding API call)
    
  Embedding question:
    [0.200, -0.450, 0.850, ...]  â† Vecteur 768D
    
    â†“ (SimilaritÃ© vs tous les chunks)
    
  Scores de similaritÃ©:
    Chunk #1: cosine_similarity(question, chunk1) = 0.750 â† Pas trÃ¨s pertinent
    Chunk #2: cosine_similarity(question, chunk2) = 0.957 â† TRÃˆS PERTINENT! âœ…
    Chunk #3: cosine_similarity(question, chunk3) = 0.823 â† Pertinent
    Chunk #4: cosine_similarity(question, chunk4) = 0.234 â† Peu pertinent
    ...
    Chunk #234: cosine_similarity(question, chunk234) = 0.445 â† Peu pertinent
    
    â†“ (Tri par score dÃ©croissant)
    
  Top-4 retrieved:
    1. Chunk #2: score=0.957 (Page 2)
    2. Chunk #3: score=0.823 (Page 3)
    3. Chunk #15: score=0.891 (Page 5)
    4. Chunk #42: score=0.867 (Page 8)

POURQUOI C'EST IMPORTANT?

Sans embeddings:
  â€¢ Impossible de trouver des rÃ©ponses
  â€¢ Recherche textuelle simple rate 90% du temps
  â€¢ Pas de comprÃ©hension du SENS

Avec embeddings (Astrali):
  â€¢ ComprÃ©hension sÃ©mantique
  â€¢ "Revenus" ~ "chiffre d'affaires" (similaires!)
  â€¢ PrÃ©cision de retrieval ~95%

================================================================================
4. PIPELINE DE VALIDATION API
================================================================================

4.1 PROCESSUS DE VALIDATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

La validation d'API key suit 5 Ã©tapes sÃ©quentielles :

Ã‰TAPE 1: VÃ‰RIFICATION DE PRÃ‰SENCE
  â”œâ”€ Check: api_key est-elle vide?
  â”œâ”€ Action: Afficher message d'erreur si vide
  â””â”€ RÃ©sultat: ValidationResult(valid=False, error_type='empty')

Ã‰TAPE 2: VÃ‰RIFICATION DE FORMAT
  â”œâ”€ Pattern regex: ^AIza[0-9A-Za-z\-_]{35}$
  â”œâ”€ Check: La clÃ© commence par 'AIza' et fait 39 caractÃ¨res?
  â”œâ”€ CaractÃ¨res autorisÃ©s: [0-9A-Za-z\-_]
  â””â”€ RÃ©sultat: ValidationResult(valid=False, error_type='format')

Ã‰TAPE 3: CONFIGURATION API
  â”œâ”€ genai.configure(api_key=api_key)
  â”œâ”€ Initialisation du client Google Generative AI
  â””â”€ PrÃ©paration pour test de connexion

Ã‰TAPE 4: TEST DE CONNEXION
  â”œâ”€ Model: gemini-2.5-flash
  â”œâ”€ Prompt: "Respond with exactly: TEST_OK"
  â”œâ”€ Timeout: 10 secondes
  â”œâ”€ Config: max_output_tokens=10, temperature=0.1
  â””â”€ Check: RÃ©ception d'une rÃ©ponse valide

Ã‰TAPE 5: GESTION DES ERREURS
  â”œâ”€ APIError 401: ClÃ© invalide/expirÃ©e
  â”œâ”€ APIError 403: Permissions insuffisantes
  â”œâ”€ APIError 429: Quota dÃ©passÃ©
  â”œâ”€ Timeout: Erreur de connexion
  â””â”€ Autres: Erreurs inconnues avec message gÃ©nÃ©rique

4.2 TYPES D'ERREURS DÃ‰TECTÃ‰ES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ error_type   â”‚ Cause & Message                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ empty        â”‚ ClÃ© vide â†’ "La clÃ© API ne peut pas Ãªtre vide"       â”‚
â”‚ format       â”‚ Format invalide â†’ "Format... commence par 'AIza'"   â”‚
â”‚ unauthorized â”‚ Code 401 â†’ "ClÃ© invalide ou expirÃ©e"                â”‚
â”‚ forbidden    â”‚ Code 403 â†’ "AccÃ¨s refusÃ© - VÃ©rifiez permissions"   â”‚
â”‚ quota        â”‚ Code 429 â†’ "Quota dÃ©passÃ© - RÃ©essayez plus tard"   â”‚
â”‚ connection   â”‚ Timeout/Erreur rÃ©seau â†’ "Erreur de connexion"      â”‚
â”‚ empty_responseâ”‚ RÃ©ponse vide â†’ "RÃ©ponse de l'API vide"            â”‚
â”‚ filtered     â”‚ RÃ©ponse filtrÃ©e â†’ "RÃ©ponse filtrÃ©e par l'API"      â”‚
â”‚ unknown      â”‚ Autre â†’ "Erreur inconnue"                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4.3 CACHE DE VALIDATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â€¢ Dictionnaire: st.session_state.api_validation_cache
â€¢ ClÃ©: hash(api_key)
â€¢ Valeur: {valid, message, service, error_type}
â€¢ Avantage: Ã‰vite les requÃªtes API rÃ©pÃ©tÃ©es pour la mÃªme clÃ©
â€¢ TTL: Session Streamlit (rÃ©initialisation au refresh)

================================================================================
5. MODE PDF - TRAITEMENT ET RAG
================================================================================

5.1 FLUX DE TRAITEMENT PDF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. UPLOAD PDF (Utilisateur)                                     â”‚
â”‚    â””â”€ Fichier stockÃ© en: st.session_state.temp_pdf_path         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. EXTRACTION TEXTE (pdf_processor.py)                          â”‚
â”‚    â”œâ”€ Fonction: extract_text_from_pdf(pdf_path)                 â”‚
â”‚    â”œâ”€ Outil: pdfplumber.open()                                  â”‚
â”‚    â”œâ”€ Par page: page.extract_text()                             â”‚
â”‚    â””â”€ Retour: {page_num: text_content}                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. NETTOYAGE DE TEXTE (pdf_processor.py)                        â”‚
â”‚    â”œâ”€ Fonction: clean_text(text)                                â”‚
â”‚    â”œâ”€ Suppress: CaractÃ¨res spÃ©ciaux, accents multiples          â”‚
â”‚    â”œâ”€ Normalize: Espaces multiples â†’ espaces simples            â”‚
â”‚    â”œâ”€ Replace: Sauts de ligne â†’ espaces                         â”‚
â”‚    â””â”€ RÃ©sultat: Texte propre et structurÃ©                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. CHUNKING DE TEXTE (pdf_processor.py)                         â”‚
â”‚    â”œâ”€ Fonction: chunk_text(text, chunk_size=500, overlap=100)   â”‚
â”‚    â”œâ”€ Taille chunk: 500 caractÃ¨res                              â”‚
â”‚    â”œâ”€ Overlap: 100 caractÃ¨res (pour contexte)                   â”‚
â”‚    â”œâ”€ StratÃ©gie: Chevauchement progressif                       â”‚
â”‚    â””â”€ RÃ©sultat: [chunk1, chunk2, ..., chunkN]                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. CRÃ‰ATION VECTOR STORE (rag/__init__.py)                      â”‚
â”‚    â”œâ”€ Classe: PDFRagPipeline                                    â”‚
â”‚    â”œâ”€ Chunks â†’ Embeddings (Gemini API)                          â”‚
â”‚    â”œâ”€ Storage: En-mÃ©moire (dictionnaire)                        â”‚
â”‚    â””â”€ Index: {chunk_id: (text, embedding, metadata)}            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. QUERY RAG (rag/__init__.py)                                  â”‚
â”‚    â”œâ”€ Input: Question utilisateur                               â”‚
â”‚    â”œâ”€ Ã‰tape 1: Embedding de la question                         â”‚
â”‚    â”œâ”€ Ã‰tape 2: SimilaritÃ© cosinus vs tous les chunks            â”‚
â”‚    â”œâ”€ Ã‰tape 3: Top-K (k=4) retrieval                            â”‚
â”‚    â”œâ”€ Ã‰tape 4: Re-ranking (utils/reranker.py)                   â”‚
â”‚    â””â”€ Output: {top_chunks, similarities}                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. GÃ‰NÃ‰RATION RÃ‰PONSE (gemini_service.py)                       â”‚
â”‚    â”œâ”€ Context: Top-4 chunks + mÃ©tadonnÃ©es                       â”‚
â”‚    â”œâ”€ Prompt: Template RAG avec contexte                        â”‚
â”‚    â”œâ”€ Model: gemini-2.5-flash                                   â”‚
â”‚    â”œâ”€ Params: temperature=0.7, max_tokens=2048                  â”‚
â”‚    â””â”€ Output: RÃ©ponse texte formatÃ©e                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8. INDEXATION SOURCES (streamlit_app/app.py)                    â”‚
â”‚    â”œâ”€ Extraction: Page numbers des chunks utilisÃ©s              â”‚
â”‚    â”œâ”€ Format: "Page X - Lines Y:Z"                              â”‚
â”‚    â”œâ”€ Stockage: st.session_state.chat_history                   â”‚
â”‚    â””â”€ Display: Liens cliquables vers pages PDF                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5.2 DÃ‰TAILS TECHNIQUES - EXTRACTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Fonction: extract_text_from_pdf(pdf_path: str) -> Dict[int, str]

Algorithme:
  1. Ouvrir PDF avec pdfplumber.open(pdf_path)
  2. ItÃ©rer sur pdf.pages:
     - Pour chaque page i:
       - Extraire texte: page.extract_text()
       - Indexer: pages_text[i+1] = text  (1-indexed pour UI)
  3. GÃ©rer erreurs: Try/Except sur tout le bloc

Retour:
  {
    1: "Contenu page 1...",
    2: "Contenu page 2...",
    ...
    N: "Contenu page N..."
  }

5.3 DÃ‰TAILS TECHNIQUES - CHUNKING
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Fonction: chunk_text(text: str, chunk_size=500, overlap=100) -> List[str]

StratÃ©gie: FenÃªtre glissante (Sliding Window)

Pseudo-code:
  chunks = []
  step = chunk_size - overlap  # 400
  
  for i in range(0, len(text), step):
    chunk = text[i : i + chunk_size]
    if chunk.strip():  # Ne pas ajouter si vide
      chunks.append(chunk)
  
  return chunks

Exemple avec chunk_size=500, overlap=100:
  â”œâ”€ Chunk 1: text[0:500]      (caractÃ¨res 0-499)
  â”œâ”€ Chunk 2: text[400:900]    (caractÃ¨res 400-899)  â† 100 caractÃ¨res overlap
  â”œâ”€ Chunk 3: text[800:1300]   (caractÃ¨res 800-1299) â† 100 caractÃ¨res overlap
  â””â”€ Chunk N: text[...]:       (dernier chunk restant)

BÃ©nÃ©fices:
  â€¢ Contexte prÃ©servÃ© aux frontiÃ¨res
  â€¢ Meilleure couverture des concepts
  â€¢ RÃ©duit la perte d'information

5.4 PIPELINE RAG - DÃ‰TAILS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Classe: PDFRagPipeline (backend/rag/__init__.py)

Initialisation:
  __init__(pdf_path: str, gemini_service: GeminiService):
    â”œâ”€ self.pdf_path = pdf_path
    â”œâ”€ self.gemini_service = gemini_service
    â”œâ”€ self.chunks = extract_text_from_pdf(pdf_path)
    â”œâ”€ self.embeddings = generate_embeddings(chunks)
    â””â”€ self.metadata = track_chunk_sources(pdf_path, chunks)

MÃ©thode query():
  query(
    user_query: str,
    top_k: int = 4,
    rerank_top_k: int = 4
  ) -> Dict[str, Any]:
    
    1. GÃ©nÃ©rer embedding de la question:
       query_embedding = gemini_service.embed(user_query)
    
    2. Calculer similaritÃ© cosinus:
       for chunk in chunks:
         similarity = cosine_similarity(query_embedding, chunk_embedding)
         scores.append((chunk_id, similarity, chunk_text))
    
    3. Trier par score:
       sorted_chunks = sort_by_score(scores)
    
    4. Prendre top_k=3 des chunks rÃ©ranking:
       top_chunks = sorted_chunks[:3]
    
    5. Re-ranking (optionnel):
       reranked = rerank_chunks(top_chunks, user_query)
    
    6. Construire contexte:
       context = format_context(reranked[:3])
    
    7. GÃ©nÃ©rer rÃ©ponse:
       response = gemini_service.generate(
         prompt=build_rag_prompt(user_query, context),
         context_chunks=reranked
       )
    
    8. Retourner rÃ©sultat:
       return {
         'response': response,
         'sources': extract_sources(reranked),
         'chunks_used': reranked
       }

================================================================================
6. MODE YFINANCE - TRAITEMENT ET RAG
================================================================================

6.1 FLUX DE TRAITEMENT YFINANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. SÃ‰LECTION DE TICKERS (Utilisateur)                           â”‚
â”‚    â””â”€ Ex: ['AAPL', 'MSFT', 'GOOGL']                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. TÃ‰LÃ‰CHARGEMENT DONNÃ‰ES (yfinance_service.py)                 â”‚
â”‚    â”œâ”€ Fonction: fetch_stock_data(tickers, period='1mo')         â”‚
â”‚    â”œâ”€ API: yfinance.download()                                  â”‚
â”‚    â”œâ”€ DonnÃ©es: OHLCV (Open, High, Low, Close, Volume)           â”‚
â”‚    â”œâ”€ Temps rÃ©el: DonnÃ©es jusqu'Ã  date du jour                  â”‚
â”‚    â””â”€ Retour: DataFrame pandas indexÃ© par ticker & date         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. TRANSFORMATION TEXTE (yfinance_service.py)                   â”‚
â”‚    â”œâ”€ Convertir DataFrame â†’ Chunks texte descriptifs            â”‚
â”‚    â”œâ”€ Format: "TICKER: AAPL, Date: 2025-12-31, Open: $150.0..." â”‚
â”‚    â”œâ”€ Inclure: Statistiques, tendances, volumes                 â”‚
â”‚    â””â”€ RÃ©sultat: [chunk1_text, chunk2_text, ...]                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. CRÃ‰ATION VECTOR STORE (rag/yfinance_rag.py)                  â”‚
â”‚    â”œâ”€ Classe: YFinanceRagAssistant                              â”‚
â”‚    â”œâ”€ Chunks â†’ Embeddings                                       â”‚
â”‚    â”œâ”€ Metadata: {ticker, date, price, volume, ...}              â”‚
â”‚    â””â”€ Index: {chunk_id: (text, embedding, metadata)}            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. QUERY RAG (rag/yfinance_rag.py)                              â”‚
â”‚    â”œâ”€ Question: "Comment se porte AAPL?"                        â”‚
â”‚    â”œâ”€ Ã‰tape 1: Embedding de la question                         â”‚
â”‚    â”œâ”€ Ã‰tape 2: SimilaritÃ© vs chunks financiers                  â”‚
â”‚    â”œâ”€ Ã‰tape 3: Top-K retrieval (k=4)                            â”‚
â”‚    â”œâ”€ Ã‰tape 4: Re-ranking par pertinence                        â”‚
â”‚    â””â”€ Output: {top_chunks, similarities, metadata}              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. GÃ‰NÃ‰RATION RÃ‰PONSE (gemini_service.py)                       â”‚
â”‚    â”œâ”€ Context: Top-4 chunks financiers                          â”‚
â”‚    â”œâ”€ Prompt: Template spÃ©cifique finance                       â”‚
â”‚    â”œâ”€ Model: gemini-2.5-flash                                   â”‚
â”‚    â””â”€ Output: Analyse avec insights financiers                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. INDEXATION SOURCES FINANCIÃˆRES                               â”‚
â”‚    â”œâ”€ Extraire: Tickers, dates, prix utilisÃ©s                   â”‚
â”‚    â”œâ”€ Format: "AAPL @$150.25 (2025-12-31)"                     â”‚
â”‚    â”œâ”€ Stockage: MÃ©tadonnÃ©es dans chat history                   â”‚
â”‚    â””â”€ Display: Sources financiÃ¨res avec donnÃ©es clÃ©s            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

6.2 YFINANCE SERVICE - DÃ‰TAILS TECHNIQUES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Classe: YFinanceService (backend/services/yfinance_service.py)

MÃ©thode: fetch_stock_data(tickers: List[str], period='1mo'):
  
  ParamÃ¨tres period supportÃ©s:
    â€¢ '1mo'  - Dernier mois
    â€¢ '3mo'  - Dernier trimestre
    â€¢ '6mo'  - Dernier semestre
    â€¢ '1y'   - Dernier an
    â€¢ 'max'  - Historique complet
  
  TICKERS SUPPORTÃ‰S DANS ASTRALI - LIMITATION Ã€ 5 TICKERS
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  
  Astrali a Ã©tÃ© optimisÃ© et testÃ© pour un ensemble LIMITÃ‰ et CONTRÃ”LÃ‰ 
  de 5 tickers seulement:
  
  âœ… TICKERS SUPPORTÃ‰S (Les seuls testÃ©s et optimisÃ©s):
    â€¢ AAPL  - Apple Inc. (Tech hardware)
    â€¢ GOOGL - Alphabet Inc. / Google (Tech software)
    â€¢ MSFT  - Microsoft Corporation (Cloud & software)
    â€¢ AMZN  - Amazon.com Inc. (E-commerce & cloud)
    â€¢ TSLA  - Tesla Inc. (Electric vehicles & energy)
  
  POURQUOI CES 5 TICKERS?
  
  Raison de la sÃ©lection:
    1. ReprÃ©sentativitÃ©: Secteurs tech diffÃ©rents
       â€¢ Hardware: AAPL (iPhone, iPad, Mac)
       â€¢ Software: MSFT (Office, Azure), GOOGL (Search, Cloud)
       â€¢ E-commerce: AMZN (Retail, AWS)
       â€¢ Innovation: TSLA (EV, Energy)
    
    2. VolatilitÃ© appropriÃ©e: Suivis rÃ©guliÃ¨rement
       â€¢ Liquid stocks (trading volume Ã©levÃ©)
       â€¢ DonnÃ©es fiables et constantes
       â€¢ Pas de gap historiques
    
    3. DonnÃ©es disponibles: Historique complet yfinance
       â€¢ + de 10 ans d'historique
       â€¢ Mises Ã  jour temps rÃ©el jusqu'Ã  clÃ´ture bourse
       â€¢ Pas d'interruption ou dÃ©listage

  LIMITES STRICTES IMPOSÃ‰ES:
  
  âŒ INTERDIT:
    â€¢ Utiliser d'autres tickers (n'ont pas Ã©tÃ© testÃ©s)
    â€¢ Ajouter des indices (^GSPC, ^DJI, etc.)
    â€¢ Ajouter des tickers internationaux autres
    â€¢ Crypto (BTC-USD, ETH-USD, etc.)
    â€¢ Tickers dÃ©listÃ© ou faible liquiditÃ©
  
  âœ… OBLIGATOIRE:
    â€¢ Utiliser UNIQUEMENT les 5 tickers listÃ©s
    â€¢ Combinaisons possibles: 1, 2, 3, 4, ou 5 tickers
    â€¢ Max 5 tickers simultanÃ©ment (limite stricte)
    â€¢ PÃ©riode: 1mo, 3mo, 6mo, 1y (recommandÃ©: 1mo)

CONFIGURATIONS RECOMMANDÃ‰ES (avec tickers limitÃ©s Ã  5):

1. USAGE LIGHT (Apprentissage / Demo):
   Tickers: ['AAPL', 'MSFT']
   PÃ©riode: '1mo'
   Chunks gÃ©nÃ©rÃ©s: ~42
   Temps loading: 1-2 sec
   âœ… Parfait pour tester

2. USAGE STANDARD (Analyse Ã©quilibrÃ©e):
   Tickers: ['AAPL', 'GOOGL', 'MSFT', 'AMZN']
   PÃ©riode: '1mo'
   Chunks gÃ©nÃ©rÃ©s: ~84
   Temps loading: 2-3 sec
   âœ… RECOMMANDÃ‰ pour production

3. USAGE COMPLET (Tous les tickers):
   Tickers: ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
   PÃ©riode: '1mo'
   Chunks gÃ©nÃ©rÃ©s: ~105
   Temps loading: 3-4 sec
   âœ… ExpÃ©rience complÃ¨te (optimal)

4. ANALYSE HISTORIQUE (Longue pÃ©riode):
   Tickers: ['AAPL', 'MSFT']  (rester Ã  2-3 pour performance)
   PÃ©riode: '1y'
   Chunks gÃ©nÃ©rÃ©s: ~252 (52 semaines Ã— 5 jours)
   Temps loading: 5-7 sec
   âš ï¸ Acceptable mais approche limites

STRUCTURE DES DONNÃ‰ES PAR TICKER:

Exemple pour 1 jour de donnÃ©es sur 1 ticker:
  {
    "Date": "2025-12-31",
    "AAPL_Open": 151.00,
    "AAPL_High": 152.50,
    "AAPL_Low": 149.75,
    "AAPL_Close": 150.25,
    "AAPL_Volume": 52000000,
    "AAPL_Adj Close": 150.25
  }

Pour 5 tickers Ã— 21 jours (1 mois) = 105 rows de donnÃ©es
TransformÃ© en chunks texte:
  "Ticker: AAPL, Date: 2025-12-31, Open: $151.00, High: $152.50, 
   Low: $149.75, Close: $150.25, Volume: 52M"

Retour (DataFrame pour 5 tickers):
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Date        â”‚ AAPL_O   â”‚ AAPL_C   â”‚ GOOGL_O  â”‚ MSFT_C   â”‚ AMZN_V   â”‚
    â”‚ (index)     â”‚ (Open)   â”‚ (Close)  â”‚ (Open)   â”‚ (Close)  â”‚ (Vol)    â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ 2025-12-01  â”‚ 151.00   â”‚ 150.25   â”‚ 182.50   â”‚ 425.75   â”‚ 68M      â”‚
    â”‚ 2025-12-02  â”‚ 150.50   â”‚ 151.75   â”‚ 183.25   â”‚ 426.50   â”‚ 72M      â”‚
    â”‚ ...         â”‚  ...     â”‚  ...     â”‚  ...     â”‚  ...     â”‚  ...     â”‚
    â”‚ 2025-12-31  â”‚ 149.75   â”‚ 150.90   â”‚ 181.50   â”‚ 424.25   â”‚ 65M      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Colonnes pour chaque ticker:
  â€¢ Ticker_Open    : Prix d'ouverture
  â€¢ Ticker_High    : Plus haut du jour
  â€¢ Ticker_Low     : Plus bas du jour
  â€¢ Ticker_Close   : Prix de fermeture (utilisÃ© pour analyses)
  â€¢ Ticker_Volume  : Volume d'actions nÃ©gociÃ©es
  â€¢ Ticker_Adj Close: Prix ajustÃ© (splits, dividendes)

PERFORMANCE AVEC CES 5 TICKERS:

Mode d'utilisation        Tickers   PÃ©riode   Chunks   Temps Total   Status
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Minimal (test)            1         1mo       21       1.5 sec       âœ… Instant
LÃ©ger                     2         1mo       42       2.0 sec       âœ… Rapide
Standard                  4         1mo       84       3.0 sec       âœ… Optimal
Complet                   5         1mo       105      3.5 sec       âœ… RecommandÃ©
Historique court          3         3mo       63       4.0 sec       âœ… Acceptable
Historique long           2         1y        252      8.0 sec       âš ï¸ Lent
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

6.3 YFINANCE RAG PIPELINE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Classe: YFinanceRagAssistant (backend/rag/yfinance_rag.py)

Initialisation:
  __init__(tickers: List[str], gemini_service: GeminiService):
    â”œâ”€ self.tickers = tickers
    â”œâ”€ self.gemini_service = gemini_service
    â”œâ”€ self.data = fetch_stock_data(tickers)
    â”œâ”€ self.chunks = transform_data_to_chunks(self.data)
    â”œâ”€ self.embeddings = generate_embeddings(self.chunks)
    â””â”€ self.metadata = extract_financial_metadata(self.data)

Transformations donnÃ©es â†’ Chunks:
  
  Input: DataFrame des donnÃ©es OHLCV
  
  Processing:
    for ticker in tickers:
      for date in dates:
        chunk = f"""
        Ticker: {ticker}
        Date: {date}
        Open: ${data[ticker]['Open'][date]:.2f}
        High: ${data[ticker]['High'][date]:.2f}
        Low:  ${data[ticker]['Low'][date]:.2f}
        Close: ${data[ticker]['Close'][date]:.2f}
        Volume: {data[ticker]['Volume'][date]:,.0f}
        Change: {((Close - Open) / Open * 100):.2f}%
        """
        chunks.append(chunk)
  
  Output: Liste de chunks structurÃ©s

MÃ©thode query():
  
  query(
    user_query: str,
    top_k: int = 4,
    rerank_top_k: int = 4
  ) -> Dict[str, Any]:
    
    Identical au RAG PDF mais:
    â€¢ Context: Chunks financiers au lieu de texte document
    â€¢ Metadata: Inclut tickers, prix, volumes
    â€¢ Sources: RÃ©fÃ©rences financiÃ¨res (ticker @ prix)
    â€¢ Prompt: SpÃ©cialisÃ© pour l'analyse financiÃ¨re

================================================================================
7. SYSTÃˆME D'INDEXATION DES SOURCES
================================================================================

7.1 ARCHITECTURE DE L'INDEXATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Structure de donnÃ©es:

chat_history = [
  {
    'role': 'user',
    'content': 'Question de l\'utilisateur',
    'timestamp': datetime.now()
  },
  {
    'role': 'assistant',
    'content': 'RÃ©ponse Astrali',
    'sources': [
      {
        'type': 'pdf',
        'page': 3,
        'text_excerpt': '...',
        'relevance_score': 0.92,
        'chunk_id': 'chunk_42'
      },
      {
        'type': 'yfinance',
        'ticker': 'AAPL',
        'date': '2025-12-31',
        'price': 150.25,
        'volume': 52000000,
        'relevance_score': 0.88
      }
    ],
    'mode': 'pdf' or 'yfinance',
    'timestamp': datetime.now(),
    'tokens_used': 1250
  }
]

7.2 INDEXATION MODE PDF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Processus:

1. Lors du query RAG:
   â”œâ”€ RÃ©cupÃ©rer top_chunks avec scores de similaritÃ©
   â”œâ”€ Pour chaque chunk:
   â”‚  â”œâ”€ Extraire page number du metadata
   â”‚  â”œâ”€ Extraire position dans le chunk (start/end char)
   â”‚  â””â”€ Calculer score de pertinence (0.0-1.0)
   â””â”€ Compiler sources

2. Format source PDF:
   {
     'type': 'pdf',
     'page': 5,
     'start_char': 250,
     'end_char': 750,
     'text_excerpt': '...',
     'relevance_score': 0.95,
     'chunk_id': 'pdf_chunk_12'
   }

3. Affichage UI:
   "ğŸ“„ Page 5 - CaractÃ¨res 250-750 [Pertinence: 95%]"
   â””â”€ Lien cliquable pour naviguer PDF viewer
   â””â”€ Tooltip avec texte extrait

7.3 INDEXATION MODE YFINANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Processus:

1. Lors du query RAG:
   â”œâ”€ RÃ©cupÃ©rer top_chunks financiers
   â”œâ”€ Pour chaque chunk:
   â”‚  â”œâ”€ Parser: ticker, date, OHLCV
   â”‚  â”œâ”€ Extraire metadata du DataFrame original
   â”‚  â””â”€ Calculer score de pertinence
   â””â”€ Compiler sources

2. Format source YFinance:
   {
     'type': 'yfinance',
     'ticker': 'AAPL',
     'date': '2025-12-31',
     'open': 151.00,
     'high': 152.50,
     'low': 149.75,
     'close': 150.25,
     'volume': 52000000,
     'relevance_score': 0.92,
     'chunk_id': 'yfinance_chunk_8'
   }

3. Affichage UI:
   "ğŸ“ˆ AAPL @ $150.25 (2025-12-31) Vol: 52M [Pertinence: 92%]"
   â””â”€ Lien pour graphiques
   â””â”€ Tooltip avec OHLCV complet

7.4 TRAÃ‡ABILITÃ‰ COMPLÃˆTE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Informations tracÃ©es par rÃ©ponse:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Query Metadata                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Question utilisateur             â”‚
â”‚ â€¢ Timestamp                        â”‚
â”‚ â€¢ Mode (PDF/YFinance)              â”‚
â”‚ â€¢ Nombre de tokens utilisÃ©s        â”‚
â”‚ â€¢ Latence (ms)                     â”‚
â”‚ â€¢ Version du modÃ¨le (Gemini 2.5)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sources UtilisÃ©es                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Pour chaque source:                â”‚
â”‚ â€¢ Type (PDF/YFinance)              â”‚
â”‚ â€¢ Localisation (page/ticker/date)  â”‚
â”‚ â€¢ Score de similaritÃ© (0.0-1.0)    â”‚
â”‚ â€¢ Texte/donnÃ©es clÃ©s               â”‚
â”‚ â€¢ Identifiant unique de chunk      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ RÃ©ponse GÃ©nÃ©rÃ©e                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Texte rÃ©ponse                    â”‚
â”‚ â€¢ Timestamp gÃ©nÃ©ration             â”‚
â”‚ â€¢ ModÃ¨le utilisÃ©                   â”‚
â”‚ â€¢ Nombre de chunks contexte        â”‚
â”‚ â€¢ Temperature & top_k utilisÃ©s     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
8. FLUX DE TRAITEMENT COMPLET
================================================================================

8.1 SCÃ‰NARIO COMPLET - MODE PDF
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SÃ©quence temporelle:

T0:00 - Utilisateur ouvre l'app
  â””â”€ Landing page affichÃ©e
  â””â”€ Recherche API key

T0:10 - Utilisateur entre la clÃ© API
  â””â”€ Validation en temps rÃ©el dÃ©marre
  â””â”€ Regex check, format validation
  â””â”€ Spinner "ğŸ” VÃ©rification de la clÃ©..."

T0:15 - ClÃ© valide
  â””â”€ API testÃ©e avec requÃªte simple
  â””â”€ âœ… Affichage "ClÃ© valide et fonctionnelle"
  â””â”€ GeminiService initialisÃ©
  â””â”€ st.session_state.gemini_service = service

T0:20 - Click "Connecter et DÃ©marrer"
  â””â”€ st.rerun()
  â””â”€ Sidebar affichÃ©e
  â””â”€ Mode selector activÃ©

T0:30 - Utilisateur sÃ©lectionne "ğŸ“„ Mode PDF"
  â””â”€ Upload widget activÃ©
  â””â”€ "Choisissez un fichier PDF"

T0:45 - Utilisateur upload rapport.pdf (5MB)
  â””â”€ Fichier stockÃ© en tempfile
  â””â”€ Path sauvegardÃ© dans session_state
  â””â”€ st.success("PDF chargÃ©!")
  â””â”€ Status: "Traitement en cours..."

T1:00 - Traitement PDF lancÃ©
  â””â”€ PDFRagPipeline.__init__(pdf_path)
  â”œâ”€ extract_text_from_pdf()
  â”‚  â””â”€ pdfplumber.open() â†’ 47 pages
  â”‚  â””â”€ Extraction de tout le texte
  â”‚  â””â”€ Result: {1: "...", 2: "...", ..., 47: "..."}
  â”œâ”€ clean_text() sur tout le contenu
  â”œâ”€ chunk_text(chunk_size=500, overlap=100)
  â”‚  â””â”€ 234 chunks gÃ©nÃ©rÃ©s
  â”œâ”€ generate_embeddings() pour tous les chunks
  â”‚  â””â”€ Appels Gemini API embeddings
  â”‚  â””â”€ 234 embeddings gÃ©nÃ©rÃ©s
  â””â”€ Indexation: {chunk_id: (text, embedding, metadata)}

T1:30 - PDF prÃªt, interface affichÃ©e
  â””â”€ Chat historique rÃ©initialisÃ©
  â””â”€ PDF viewer activÃ© (page 1)
  â””â”€ Input de question activÃ©

T2:00 - Utilisateur pose une question
  â””â”€ Saisie: "Quel est le chiffre d'affaires total?"
  â””â”€ Click "Envoyer"

T2:10 - Traitement de la question
  â””â”€ query() appelÃ©
  â”œâ”€ generate_embedding("Quel est le chiffre d'affaires total?")
  â”‚  â””â”€ Embedding gÃ©nÃ©rÃ©
  â”œâ”€ SimilaritÃ© cosinus vs 234 embeddings
  â”‚  â””â”€ Scores calculÃ©s
  â”œâ”€ Sort & Top-4:
  â”‚  â”œâ”€ Chunk #42: 0.96 similarity
  â”‚  â”œâ”€ Chunk #15: 0.93 similarity
  â”‚  â”œâ”€ Chunk #67: 0.91 similarity
  â”‚  â””â”€ Chunk #103: 0.89 similarity
  â”œâ”€ Rerank si nÃ©cessaire
  â””â”€ Contexte compilÃ©

T2:15 - GÃ©nÃ©ration rÃ©ponse
  â””â”€ Prompt RAG construit:
     """
     Context from document:
     [Chunk #42 text]
     [Chunk #15 text]
     [Chunk #67 text]
     [Chunk #103 text]
     
     User Question: Quel est le chiffre d'affaires total?
     
     Please provide a detailed answer...
     """
  â””â”€ gemini-2.5-flash appelÃ©
  â””â”€ RÃ©ponse gÃ©nÃ©rÃ©e progressivement (streaming)

T2:25 - RÃ©ponse affichÃ©e avec sources
  â””â”€ Texte: "Le chiffre d'affaires total de..."
  â””â”€ Sources:
     â€¢ ğŸ“„ Page 5 - [Lien clickable]
     â€¢ ğŸ“„ Page 12 - [Lien clickable]
     â€¢ ğŸ“„ Page 18 - [Lien clickable]
     â€¢ ğŸ“„ Page 23 - [Lien clickable]
  â””â”€ Chat history sauvegardÃ©
  â””â”€ Interface prÃªte pour nouvelle question

T2:30+ - Utilisateur pose nouvelle question
  â””â”€ Cycle rÃ©pÃ©tÃ© avec mÃªme contexte PDF
  â””â”€ Aucun traitement supplÃ©mentaire du PDF
  â””â”€ Seule la question est rÃ©-embedÃ©e

8.2 SCÃ‰NARIO COMPLET - MODE YFINANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

T0:00 - Utilisateur sÃ©lectionne "ğŸ“ˆ Mode YFinance"
  â””â”€ Multi-select: Choisir tickers
  â””â”€ DÃ©faut: ['AAPL']
  â””â”€ Exemple sÃ©lection: ['AAPL', 'MSFT', 'GOOGL', 'TSLA']

T0:10 - Click "Charger les donnÃ©es"
  â””â”€ Status: "ğŸ“Š TÃ©lÃ©chargement des donnÃ©es..."

T0:20 - TÃ©lÃ©chargement yfinance
  â””â”€ YFinanceService.fetch_stock_data(['AAPL', 'MSFT', 'GOOGL', 'TSLA'])
  â”œâ”€ yfinance.download() pour chaque ticker
  â”œâ”€ PÃ©riode: 1 mois (dÃ©faut)
  â”œâ”€ RÃ©cupÃ©ration OHLCV
  â””â”€ DataFrame compilÃ©: ~21 jours Ã— 5 tickers = 105 points

T0:30 - Transformation donnÃ©es â†’ Chunks
  â””â”€ transform_data_to_chunks(dataframe)
  â”œâ”€ ItÃ©ration dates Ã— tickers
  â”œâ”€ GÃ©nÃ©ration chunks textuels
  â”œâ”€ Format: "Ticker: AAPL, Date: 2025-12-31, O: $151, ..."
  â””â”€ ~85 chunks gÃ©nÃ©rÃ©s

T0:40 - Embeddings gÃ©nÃ©rÃ©s
  â””â”€ generate_embeddings() pour 85 chunks
  â””â”€ ParallÃ©lisation possible

T0:50 - DonnÃ©es prÃªtes, interface affichÃ©e
  â””â”€ Graphiques OHLCV affichÃ©s pour chaque ticker
  â””â”€ Chat input activÃ©

T1:00 - Utilisateur pose une question
  â””â”€ Saisie: "Quel ticker a la meilleure performance?"
  â””â”€ Click "Envoyer"

T1:10 - Query RAG lancÃ©e
  â””â”€ query() appelÃ©
  â”œâ”€ Embedding question gÃ©nÃ©rÃ©
  â”œâ”€ SimilaritÃ© vs 85 chunks financiers
  â”œâ”€ Top-4 retrieved
  â””â”€ Rerank + contexte compilÃ©

T1:15 - GÃ©nÃ©ration rÃ©ponse
  â””â”€ Gemini appelÃ© avec contexte financier
  â””â”€ RÃ©ponse spÃ©cialisÃ©e analyse financiÃ¨re

T1:20 - RÃ©ponse + sources affichÃ©es
  â””â”€ Texte: "AAPL a une meilleure performance avec..."
  â””â”€ Sources:
     â€¢ ğŸ“ˆ AAPL @ $150.25 (2025-12-31)
     â€¢ ğŸ“ˆ MSFT @ $425.50 (2025-12-31)
     â€¢ ğŸ“ˆ GOOGL @ $181.75 (2025-12-31)
     â€¢ ğŸ“ˆ TSLA @ $245.30 (2025-12-31)

================================================================================
9. PERFORMANCES ET OPTIMISATIONS
================================================================================

9.1 MÃ‰TRIQUES DE PERFORMANCE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

OpÃ©ration                    Temps Moyen    Optimisations
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Validation API key           2-3 sec        â€¢ Cache de validation
                                            â€¢ ParallÃ©lisation possibleet

Extraction PDF (10 pages)    1-2 sec        â€¢ pdfplumber optimisÃ©
                                            â€¢ Pas de dÃ©pendance OCR

Chunking texte (100KB)       <100ms         â€¢ Algorithme vectorisÃ©

GÃ©nÃ©ration embeddings        500ms-2sec     â€¢ Appels API batch
(100 chunks)                                â€¢ Cache possible

Query similaritÃ©             50-100ms       â€¢ Scipy cosine_similarity
(vs 200 chunks)                             â€¢ Numpy vectorisÃ©

GÃ©nÃ©ration rÃ©ponse           3-8 sec        â€¢ Gemini 2.5-flash rapide
(streaming)                                 â€¢ Contexte compact

Total End-to-End:            5-12 sec       â€¢ Cache multi-niveaux
                                            â€¢ Session state Streamlit

9.2 OPTIMISATIONS IMPLÃ‰MENTÃ‰ES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. CACHE DE SESSION STREAMLIT
   â”œâ”€ PDF dÃ©jÃ  chargÃ©? â†’ RÃ©utiliser RAG pipeline
   â”œâ”€ YFinance donnÃ©es chargÃ©es? â†’ RÃ©utiliser
   â”œâ”€ Validation API? â†’ Cache dict
   â””â”€ Ã‰conomies: 50-70% temps second query

2. CHUNKING STRATÃ‰GIQUE
   â”œâ”€ Taille 500 chars = Ã©quilibre contexte/nombre
   â”œâ”€ Overlap 100 chars = pas de perte sÃ©mantique
   â””â”€ RÃ©sultat: ~0.2 chunk/100chars

3. VECTORISATION NUMPY
   â”œâ”€ OpÃ©rations batch au lieu de loops
   â”œâ”€ Cosine similarity vectorisÃ©e
   â””â”€ Speedup ~5-10x vs loop Python

4. EMBEDDINGS CACHING
   â”œâ”€ Stockage en mÃ©moire session
   â”œâ”€ Pas de recalcul embeddings
   â””â”€ Temps zero pour requÃªtes multiples

5. LAZY LOADING
   â”œâ”€ PDF viewer initialisÃ© seulement si mode PDF
   â”œâ”€ Graphiques YFinance seulement si mode YFinance
   â””â”€ Interface lÃ©gÃ¨re et rÃ©active

9.3 LIMITES ET SCALABILITÃ‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Limitations actuelles:
  â€¢ PDF max: ~50-100 pages (stockage mÃ©moire)
  â€¢ Chunks indexÃ©s: ~500-1000 (pour performance cosine)
  â€¢ Tickers YFinance: ~20-50 (limite yfinance)
  â€¢ Historique chat: ~100 messages (session Streamlit)

9.3.1 LIMITATIONS DÃ‰TAILLÃ‰ES PAR MODE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MODE PDF:

Limites techniquement imposÃ©es:
  â€¢ Taille fichier: Max 100MB (limite Streamlit upload)
  â€¢ Pages: ~50-100 pages recommandÃ©
  â€¢ Texte total: ~500KB-5MB (stockage mÃ©moire session)
  â€¢ Chunks: ~500-1000 chunks en mÃ©moire
  â€¢ Latence retrieval: ~50-100ms pour similaritÃ©

Pourquoi ces limites?
  â€¢ MÃ©moire session: Streamlit stocke tout en RAM
  â€¢ SimilaritÃ© cosinus: O(n) complexity oÃ¹ n=nombre de chunks
  â€¢ + 500 chunks: Latence devient ~100ms
  â€¢ + 1000 chunks: Risque dÃ©passement mÃ©moire Streamlit

Cas d'usage typiques:
  âœ… Rapports financiers annuels (50-100 pages)
  âœ… Prospectus (30-50 pages)
  âœ… Ã‰tudes de marchÃ© (40-80 pages)
  âŒ Livres entiers (>500 pages)
  âŒ Bases de donnÃ©es texte (>10MB)

MODE YFINANCE - LIMITATION Ã€ EXACTEMENT 5 TICKERS:

Astrali a Ã©tÃ© conÃ§u et testÃ© pour fonctionner UNIQUEMENT avec ces 5 tickers:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TICKERS AUTORISÃ‰S (et SEULS autorisÃ©s)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. AAPL   - Apple Inc.                                           â”‚
â”‚ 2. GOOGL  - Alphabet Inc.                                        â”‚
â”‚ 3. MSFT   - Microsoft Corporation                                â”‚
â”‚ 4. AMZN   - Amazon.com Inc.                                      â”‚
â”‚ 5. TSLA   - Tesla Inc.                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

RESTRICTION STRICTE:

âŒ INTERDIT:
  â€¢ Utiliser des tickers autres que ceux listÃ©s
  â€¢ Ajouter des indices boursiers (^GSPC, ^DJI, etc.)
  â€¢ Cryptomonnaies (BTC-USD, ETH-USD, etc.)
  â€¢ Tickers internationaux autres
  â€¢ Tickers dÃ©listÃ©s ou faible liquiditÃ©
  â€¢ Tickers non-testÃ©s

âœ… PERMIS:
  â€¢ Utiliser 1, 2, 3, 4, ou 5 tickers de la liste
  â€¢ Combinaisons quelconques des 5
  â€¢ Periods: '1mo' (recommandÃ©), '3mo', '6mo', '1y'
  â€¢ Usage simultanÃ©: UN SEUL utilisateur par session

CONFIGURATION RECOMMANDÃ‰E:

Combinaisons testÃ©es et validÃ©es:
  1. Solo ticker:
     â€¢ ['AAPL']  ou ['GOOGL'] ou ['MSFT'] ou ['AMZN'] ou ['TSLA']
     â€¢ Chunks: 21 (1 mois) ou 42 (2 mois)
     â€¢ Temps: 1.5-2 sec
  
  2. Duo (2 tickers):
     â€¢ ['AAPL', 'MSFT'] ou ['GOOGL', 'AMZN'] etc.
     â€¢ Chunks: 42 (1 mois)
     â€¢ Temps: 2-2.5 sec
  
  3. Trio (3 tickers):
     â€¢ ['AAPL', 'MSFT', 'GOOGL'] etc.
     â€¢ Chunks: 63 (1 mois)
     â€¢ Temps: 2.5-3 sec
  
  4. Quartet (4 tickers):
     â€¢ ['AAPL', 'GOOGL', 'MSFT', 'AMZN'] etc.
     â€¢ Chunks: 84 (1 mois)
     â€¢ Temps: 3-3.5 sec
     â€¢ âœ… CONFIGURATION STANDARD RECOMMANDÃ‰E
  
  5. Complet (5 tickers):
     â€¢ ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA']
     â€¢ Chunks: 105 (1 mois)
     â€¢ Temps: 3.5-4 sec
     â€¢ âœ… CONFIGURATION COMPLÃˆTE (OPTIMAL)

LIMITES STRICTES Ã€ RESPECTER:

Taille maximum:
  â€¢ Nombre tickers: MAX 5 (pas plus!)
  â€¢ PÃ©riode donnÃ©es: MAX 1 an ('1y')
  â€¢ Chunks gÃ©nÃ©rÃ©s: MAX ~252 (52 semaines Ã— 5 jours)
  â€¢ Embeddings: MAX ~800KB (252 chunks Ã— 768D Ã— 4 bytes)

Performance garantie:
  â€¢ Avec 5 tickers Ã— 1mo: ~3.5-4 sec pour load+indexation
  â€¢ Query time: 0.5-1 sec (retrieval+generation combinÃ©s)
  â€¢ Temps total utilisateur: 4-5 sec premiÃ¨re requÃªte
  â€¢ RequÃªtes suivantes: 0.5-1 sec (cache active)

Pourquoi ces limites STRICTES?

1. Validation: Seuls ces 5 tickers ont Ã©tÃ© testÃ©s
2. QualitÃ©: Garantir performance et stabilitÃ©
3. CoÃ»t API: Limiter usage Gemini embeddings
4. MÃ©moire: Streamlit Cloud a ~1GB RAM limite
5. Latence: Maintenir <4 sec pour UX fluide

RESPECT DE CES LIMITATIONS:

Impact utilisateur s'il les viole:
  â€¢ + de 5 tickers â†’ Erreur potentielle ou latence >10 sec
  â€¢ Tickers non-listÃ©s â†’ Pas de donnÃ©es yfinance
  â€¢ Tickers crypto â†’ Non supportÃ© (erreur yfinance)
  â€¢ PÃ©riode > 1 an â†’ Potentiellement instable

ScalabilitÃ©:
  â€¢ MontÃ©e en charge: ~10 utilisateurs concurrent (Streamlit)
  â€¢ Pour production: Passer Ã  FastAPI + PostgreSQL + Vector DB
  â€¢ Pour plus de tickers: Architecture dÃ©diÃ©e requise

================================================================================
10. SÃ‰CURITÃ‰ ET BONNES PRATIQUES
================================================================================

10.1 SÃ‰CURITÃ‰ API
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Gestion clÃ©s API:
   â”œâ”€ Type "password" â†’ MasquÃ©e Ã  l'Ã©cran
   â”œâ”€ Ne jamais logger la clÃ© complÃ¨te
   â”œâ”€ Validation format strict (regex)
   â”œâ”€ Cache par session (pas fichier disque)
   â””â”€ Destruction session = destruction clÃ©

2. Erreurs dÃ©tectÃ©es:
   â”œâ”€ 401 Unauthorized: ClÃ© invalide/expirÃ©e
   â”œâ”€ 403 Forbidden: Permissions insuffisantes
   â”œâ”€ 429 Too Many Requests: Quota dÃ©passÃ©
   â”œâ”€ Timeout: Erreur rÃ©seau/proxy
   â””â”€ Autres: Erreur gÃ©nÃ©rique sÃ»re

3. Pas de secrets hardcodÃ©s:
   â”œâ”€ Aucune clÃ© en clair dans le code
   â”œâ”€ Secrets Streamlit Cloud: Fichier .streamlit/secrets.toml
   â”œâ”€ Exemple: GEMINI_API_KEY=${st.secrets["GEMINI_API_KEY"]}
   â””â”€ Meilleure pratique: Variables d'environnement

10.2 SÃ‰CURITÃ‰ DONNÃ‰ES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Fichiers temporaires:
   â”œâ”€ tempfile.NamedTemporaryFile() sÃ©curisÃ©
   â”œâ”€ Permissions restrictives (0600)
   â”œâ”€ Auto-suppression Ã  fermeture
   â””â”€ Aucun accÃ¨s disque persistent

2. DonnÃ©es utilisateur:
   â”œâ”€ Session Streamlit = donnÃ©es en mÃ©moire
   â”œâ”€ Auto-expiration session
   â”œâ”€ Pas de sauvegarde base de donnÃ©es
   â”œâ”€ Chat history local seulement
   â””â”€ Export optionnel par utilisateur

3. Uploads PDF:
   â”œâ”€ Validation type MIME
   â”œâ”€ Limite taille (100MB recommandÃ©e)
   â”œâ”€ Stockage temporaire seulement
   â”œâ”€ Scan antivirus possible (optionnel)
   â””â”€ Suppression explicite ou auto

10.3 BONNES PRATIQUES CODE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Validation entrÃ©es:
   â”œâ”€ Regex patterns pour API keys
   â”œâ”€ Type hints Python (str, List, Dict)
   â”œâ”€ Pydantic pour config validation
   â”œâ”€ Longueur max fichiers
   â””â”€ CaractÃ¨res autorisÃ©s checks

2. Gestion erreurs:
   â”œâ”€ Try/Except granulaires
   â”œâ”€ Messages d'erreur utilisateur-friendly
   â”œâ”€ Logging pour debugging (sans sensitive data)
   â”œâ”€ Fallbacks et valeurs par dÃ©faut
   â””â”€ Timeouts sur toutes les API calls

3. Rate limiting:
   â”œâ”€ Limiter requÃªtes API Gemini
   â”œâ”€ Throttle yfinance downloads
   â”œâ”€ Alerter utilisateur si quotas approchent
   â””â”€ Graceful degradation

4. Monitoring:
   â”œâ”€ Logs structurÃ©s (fichier ou cloud)
   â”œâ”€ MÃ©triques: latence, tokens, erreurs
   â”œâ”€ Alertes sur anomalies
   â””â”€ Audit trail pour compliance

10.4 DEPLOYMENT SÃ‰CURISÃ‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Recommandations:

1. Streamlit Cloud:
   â”œâ”€ Secrets dans .streamlit/secrets.toml
   â”œâ”€ Git repo privÃ© si donnÃ©es sensibles
   â”œâ”€ HTTPS automatique
   â”œâ”€ Rate limiting Cloud

2. Auto-hÃ©bergement:
   â”œâ”€ SSL/TLS obligatoire
   â”œâ”€ Nginx/Reverse proxy en front
   â”œâ”€ Firewall rules
   â”œâ”€ CORS appropriÃ©
   â””â”€ Rate limiting applicatif

3. Monitoring de sÃ©curitÃ©:
   â”œâ”€ Logs centralisÃ©s (Datadog, ELK, etc.)
   â”œâ”€ Alertes anomalies
   â”œâ”€ Backup rÃ©guliers
   â””â”€ Tests de pÃ©nÃ©tration

================================================================================
CONCLUSION
================================================================================

Astrali est une solution RAG complÃ¨te et robuste pour l'analyse financiÃ¨re.
L'architecture modulaire permet l'extension facile (nouveaux modes, sources).

Points forts:
  âœ… Validation API robuste et transparente
  âœ… Deux modes complÃ©mentaires (PDF + YFinance)
  âœ… Indexation sources avec traÃ§abilitÃ© complÃ¨te
  âœ… Interface moderne et responsive
  âœ… Code de qualitÃ© production
  âœ… Documentation complÃ¨te

Prochaines Ã©volutions possibles:
  â€¢ OCR pour PDFs scannÃ©s (Tesseract/pytesseract)
  â€¢ Support autres formats (Excel, CSV, DOCX)
  â€¢ Persistance donnÃ©es (PostgreSQL + Vector DB)
  â€¢ API REST pour intÃ©grations tierces
  â€¢ Mobile app React Native
  â€¢ Real-time data streaming WebSocket

================================================================================
FIN DU RAPPORT
================================================================================
